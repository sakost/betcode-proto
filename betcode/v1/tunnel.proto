// BetCode Tunnel Service
// Bidirectional tunnel between relay and daemon for proxied requests.
//
// Version: v1

syntax = "proto3";

package betcode.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

// TunnelService manages the persistent tunnel between relay and daemon.
service TunnelService {
  // OpenTunnel establishes a bidirectional stream for proxied requests.
  // Daemon connects and keeps this stream open for the lifetime of the connection.
  rpc OpenTunnel(stream TunnelFrame) returns (stream TunnelFrame);

  // Register announces a daemon's machine to the relay.
  rpc Register(TunnelRegisterRequest) returns (TunnelRegisterResponse);

  // Heartbeat keeps the tunnel alive and reports daemon health.
  rpc Heartbeat(TunnelHeartbeat) returns (TunnelHeartbeat);
}

// =============================================================================
// Tunnel Frame (bidirectional envelope)
// =============================================================================

// TunnelFrame is the envelope for all messages sent through the tunnel.
message TunnelFrame {
  string request_id = 1;
  FrameType frame_type = 2;
  google.protobuf.Timestamp timestamp = 3;

  oneof payload {
    StreamPayload stream_data = 10;
    TunnelError error = 11;
    TunnelControl control = 12;
  }
}

// FrameType identifies the purpose of a tunnel frame.
enum FrameType {
  FRAME_TYPE_UNSPECIFIED = 0;
  // Request from relay to daemon (wraps a client gRPC call).
  FRAME_TYPE_REQUEST = 1;
  // Response from daemon to relay (wraps a gRPC response).
  FRAME_TYPE_RESPONSE = 2;
  // Streaming data chunk (for bidi-streaming proxied calls).
  FRAME_TYPE_STREAM_DATA = 3;
  // End of stream marker.
  FRAME_TYPE_STREAM_END = 4;
  // Error frame.
  FRAME_TYPE_ERROR = 5;
  // Control frame (tunnel management).
  FRAME_TYPE_CONTROL = 6;
}

// =============================================================================
// Encrypted Payload
// =============================================================================

// EncryptedPayload wraps E2E encrypted content.
// The relay cannot decrypt this â€” only the CLI and daemon share the session key.
message EncryptedPayload {
  // ChaCha20-Poly1305 encrypted data (includes 16-byte AEAD tag).
  bytes ciphertext = 1;
  // 12-byte nonce used for this encryption.
  bytes nonce = 2;
  // Sender's ephemeral X25519 public key (included in first message only).
  bytes ephemeral_pubkey = 3;
}

// =============================================================================
// Stream Payload
// =============================================================================

// StreamPayload carries the serialized gRPC request/response through the tunnel.
message StreamPayload {
  // The gRPC service method being proxied (e.g. "betcode.v1.AgentService/Converse").
  string method = 1;
  // E2E encrypted protobuf bytes of the request or response.
  EncryptedPayload encrypted = 2;
  // Sequence number for ordering within a stream.
  uint64 sequence = 3;
  // Metadata headers to forward.
  map<string, string> metadata = 4;
}

// =============================================================================
// Tunnel Error
// =============================================================================

// TunnelError reports an error within the tunnel.
message TunnelError {
  TunnelErrorCode code = 1;
  string message = 2;
  map<string, string> details = 3;
}

// TunnelErrorCode categorizes tunnel errors.
enum TunnelErrorCode {
  TUNNEL_ERROR_CODE_UNSPECIFIED = 0;
  TUNNEL_ERROR_CODE_INTERNAL = 1;
  TUNNEL_ERROR_CODE_TIMEOUT = 2;
  TUNNEL_ERROR_CODE_NOT_FOUND = 3;
  TUNNEL_ERROR_CODE_UNAUTHORIZED = 4;
  TUNNEL_ERROR_CODE_UNAVAILABLE = 5;
}

// =============================================================================
// Tunnel Control
// =============================================================================

// TunnelControl carries tunnel management messages.
message TunnelControl {
  TunnelControlType control_type = 1;
  map<string, string> params = 2;
}

// TunnelControlType identifies tunnel control operations.
enum TunnelControlType {
  TUNNEL_CONTROL_TYPE_UNSPECIFIED = 0;
  // Sent by relay to request tunnel drain (graceful shutdown).
  TUNNEL_CONTROL_TYPE_DRAIN = 1;
  // Sent by daemon to acknowledge drain.
  TUNNEL_CONTROL_TYPE_DRAIN_ACK = 2;
  // Ping/pong for tunnel-level keepalive.
  TUNNEL_CONTROL_TYPE_PING = 3;
  TUNNEL_CONTROL_TYPE_PONG = 4;
  // E2E key exchange: carries ephemeral public keys for session key derivation.
  TUNNEL_CONTROL_TYPE_KEY_EXCHANGE = 10;
}

// =============================================================================
// Key Exchange
// =============================================================================

// KeyExchangeRequest is sent by the CLI to initiate a key exchange with a daemon.
message KeyExchangeRequest {
  string machine_id = 1;
  bytes identity_pubkey = 2;
  string fingerprint = 3;
  // Client's ephemeral X25519 public key for this session.
  bytes ephemeral_pubkey = 4;
}

// KeyExchangeResponse carries the daemon's identity info back to the CLI.
message KeyExchangeResponse {
  bytes daemon_identity_pubkey = 1;
  string daemon_fingerprint = 2;
  // Daemon's ephemeral X25519 public key for this session.
  bytes daemon_ephemeral_pubkey = 3;
}

// =============================================================================
// Registration
// =============================================================================

message TunnelRegisterRequest {
  string machine_id = 1;
  string machine_name = 2;
  map<string, string> capabilities = 3;
  // Daemon's X25519 identity public key (32 bytes) for E2E encryption.
  bytes identity_pubkey = 4;
}

message TunnelRegisterResponse {
  bool accepted = 1;
  string relay_id = 2;
  int64 heartbeat_interval_secs = 3;
}

// =============================================================================
// Heartbeat
// =============================================================================

message TunnelHeartbeat {
  string machine_id = 1;
  google.protobuf.Timestamp timestamp = 2;
  uint32 active_sessions = 3;
  float cpu_usage_percent = 4;
  float memory_usage_percent = 5;
}
